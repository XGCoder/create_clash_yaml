import logging
import os
import copy
import yaml
import re
from datetime import datetime

logger = logging.getLogger(__name__)

class ClashConfigGenerator:
    """Clash配置生成器（基于模板）"""

    def __init__(self, template_path: str):
        self.template_path = template_path
        self.config = self._load_template(template_path)
        self.port_mappings = {}
        logger.info(f"从模板 {template_path} 加载配置")

    def _load_template(self, template_path: str) -> dict:
        if not os.path.exists(template_path):
            logger.error(f"模板文件未找到: {template_path}")
            raise FileNotFoundError(f"模板文件未找到: {template_path}")
        with open(template_path, 'r', encoding='utf-8') as f:
            template = yaml.safe_load(f)
        
        if not isinstance(template, dict):
            logger.error(f"模板文件 '{template_path}' 格式错误: 根级别必须是字典 (dictionary/map)，而不是列表 (list) 或空文件。")
            raise TypeError(f"模板文件 '{template_path}' 格式错误: 根级别必须是字典。")
            
        return template

    def add_proxies(self, new_proxies: list):
        if 'proxies' not in self.config or not isinstance(self.config.get('proxies'), list):
            self.config['proxies'] = []

        # 保留"直连"等基础节点,清除其他订阅节点
        # 这样可以避免节点累积问题,每次生成配置时只包含本次输入的订阅节点
        base_nodes = [p for p in self.config['proxies'] if isinstance(p, dict) and p.get('name') == '直连']
        self.config['proxies'] = base_nodes
        logger.info(f"清除旧订阅节点,保留 {len(base_nodes)} 个基础节点")

        # 清理新节点中的 _source 字段
        for proxy in new_proxies:
            if isinstance(proxy, dict):
                proxy.pop('_source', None)

        existing_names = {p.get('name') for p in self.config['proxies']}

        for proxy in new_proxies:
            if isinstance(proxy, dict) and proxy.get('name') not in existing_names:
                self.config['proxies'].append(proxy)
                existing_names.add(proxy.get('name'))

    def generate_port_mappings(self, node_port_mappings: dict):
        self.port_mappings = node_port_mappings

    def generate_full_config(self) -> str:
        logger.info("--- Starting Full Config Generation (Final Hybrid Approach) ---")
        config = copy.deepcopy(self.config)

        # --- Clean proxies: remove _source field ---
        if 'proxies' in config and isinstance(config['proxies'], list):
            for proxy in config['proxies']:
                if isinstance(proxy, dict) and '_source' in proxy:
                    del proxy['_source']

        # --- Prepare data ---
        config['meta'] = {
            'name': 'Generated by Fingerfly',
            'author': 'Fingerfly',
            'created': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'generator': 'Clash Config Generator'
        }

        if self.port_mappings:
            listeners = []
            for i, (proxy_name, port) in enumerate(self.port_mappings.items()):
                listeners.append({
                    "name": f"mixed{i}",
                    "type": "mixed",
                    "port": port,
                    "proxy": proxy_name
                })
            config["listeners"] = listeners

        # --- Final Assembly: The definitive hybrid approach ---
        final_yaml_parts = []

        # This serializer is for flow-style sections ONLY.
        def flow_serializer(data):
            if data is None: return 'null'
            if isinstance(data, bool): return 'true' if data else 'false'
            if isinstance(data, (int, float)): return str(data)
            if isinstance(data, str):
                # 空字符串必须用引号,否则在flow-style中会被省略
                if data == '':
                    return "''"

                # 智能判断是否需要引号:只对真正需要的情况添加引号
                # 需要引号的情况:
                # 1. 包含冒号(YAML键值分隔符)
                # 2. 以#开头(注释符)
                # 3. 是YAML保留字
                # 4. 包含YAML特殊语法字符: {}[]、&*|>!%
                # 注意:
                # - 连字符-、点号.、下划线_在值中是安全的,不需要加引号
                # - 空格在flow-style上下文中是安全的,不需要加引号
                # - IP地址、UUID、emoji等在flow-style的值位置都是安全的,不需要加引号

                needs_quotes = (
                    bool(re.search(r'[:\{\}\[\],&*|>!%]|^#', data)) or
                    data in ('true', 'false', 'null', 'yes', 'no', 'on', 'off')
                )
                if needs_quotes:
                    escaped_data = data.replace("'", "''")
                    return f"'{escaped_data}'"
                return data
            if isinstance(data, dict):
                # DO NOT quote keys, only values.
                items = [f"{k}: {flow_serializer(v)}" for k, v in data.items()]
                return f"{{{', '.join(items)}}}"
            if isinstance(data, list):
                # This handles lists inside flow-style dicts, e.g., the proxies list in a proxy-group.
                # It does NOT handle the top-level `rules` list.
                items = [flow_serializer(item) for item in data]
                return f"[{', '.join(items)}]"
            return str(data)

        # We will manually build the output string.
        # The order is critical - Clash expects: basic config -> dns -> proxies -> proxy-groups -> rules
        key_order_before_proxies = [
            'port', 'socks-port', 'redir-port', 'mixed-port', 'tproxy-port', 'allow-lan',
            'bind-address', 'ipv6', 'unified-delay', 'tcp-concurrent', 'log-level', 'find-process-mode',
            'global-client-fingerprint', 'keep-alive-idle', 'keep-alive-interval',
            'profile', 'sniffer', 'tun', 'dns'
        ]
        key_order_after_proxies = ['rules', 'rule-anchor', 'rule-providers', 'proxy-providers', 'meta']

        # Separate keys for different formatting
        flow_style_keys = {'proxies', 'proxy-groups', 'listeners'}
        block_style_config_before = {}
        block_style_config_after = {}

        # Prepare the block-style dictionary for PyYAML - BEFORE proxies
        for key in key_order_before_proxies:
            if key in config and key not in flow_style_keys:
                block_style_config_before[key] = config[key]

        # Prepare the block-style dictionary for PyYAML - AFTER proxies
        for key in key_order_after_proxies:
            if key in config and key not in flow_style_keys:
                block_style_config_after[key] = config[key]

        # Add any remaining keys to the after-block config
        for key, value in config.items():
            if key not in key_order_before_proxies and key not in key_order_after_proxies and key not in flow_style_keys:
                block_style_config_after[key] = value

        # Step 1: Render basic config sections (before proxies)
        if block_style_config_before:
            block_yaml_before = yaml.dump(
                block_style_config_before,
                allow_unicode=True,
                sort_keys=False,
                default_flow_style=False,
                indent=2
            )
            final_yaml_parts.append(block_yaml_before.rstrip())

        # Step 2: Manually render the flow-style sections (proxies and proxy-groups)
        for key in ['proxies', 'proxy-groups']:
            if key in config and config[key]:
                final_yaml_parts.append(f"{key}:")
                for item in config[key]:
                    final_yaml_parts.append(f"- {flow_serializer(item)}")

        # Step 3: Render config sections that come after proxies (rules, etc.)
        if 'proxy-providers' not in block_style_config_after:
            block_style_config_after['proxy-providers'] = None

        if block_style_config_after:
            block_yaml_after = yaml.dump(
                block_style_config_after,
                allow_unicode=True,
                sort_keys=False,
                default_flow_style=False,
                indent=2
            )
            final_yaml_parts.append(block_yaml_after.rstrip())

        # Step 4: Manually render listeners at the end, if they exist
        if 'listeners' in config and config['listeners']:
            final_yaml_parts.append("listeners:")
            for item in config['listeners']:
                final_yaml_parts.append(f"- {flow_serializer(item)}")

        logger.info("YAML configuration generated successfully.")
        return "\n".join(part for part in final_yaml_parts if part)

    def save_config(self, file_path: str) -> bool:
        yaml_str = self.generate_full_config()
        dir_path = os.path.dirname(file_path)
        if dir_path and not os.path.exists(dir_path):
            os.makedirs(dir_path)
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(yaml_str)
            logger.info(f"配置已成功保存到: {file_path}")
            return True
        except IOError as e:
            logger.error(f"保存配置文件失败: {e}")
            return False
